/************************************************************************/
/* Copyright 2014-2018 NXP Semiconductors                               */
/* Copyright 2020 GOODIX                                                */
/*                                                                      */
/* GOODIX Confidential. This software is owned or controlled by GOODIX  */
/* and may only be used strictly in accordance with the applicable      */
/* license terms.  By expressly accepting such terms or by downloading, */
/* installing, activating and/or otherwise using the software, you are  */
/* agreeing that you have read, and that you agree to comply with and   */
/* are bound by, such license terms.                                    */
/* If you do not agree to be bound by the applicable license terms,     */
/* then you may not retain, install, activate or otherwise use the      */
/* software.                                                            */
/*                                                                      */
/************************************************************************/


/***************************************************************
 * !!! AUTOGENERATED CODE, PLEASE DO NOT MANUALLY EDIT !!!
 ***************************************************************/

#ifndef CMDLINE_H_
#define CMDLINE_H_



/** @brief The command line options structure */
struct gengetopt_args_info
{
    const char *help_help; /**< @brief Print help and exit help description.  */
    const char *full_help_help; /**< @brief Print help, including hidden options, and exit help description.  */

    int version_given; /* number of times this option was entered */
    const char *version_help; /**< @brief Print version and exit */
    char * version_orig; /* input argv string */
    int version_arg; /* value of type */
    // Device operation options:
    int start_given; /* number of times this option was entered */
    const char *start_help; /**< @brief device power up and start */
    char * start_orig; /* input argv string */
    char * start_arg; /* value of type */
    int stop_given; /* number of times this option was entered */
    const char *stop_help; /**< @brief device stop and power down */
    char * stop_orig; /* input argv string */
    int stop_arg; /* value of type */
    int volume_given; /* number of times this option was entered */
    const char *volume_help; /**< @brief set volume step */
    char * volume_orig; /* input argv string */
    int volume_arg; /* value of type */
    int profile_given; /* number of times this option was entered */
    const char *profile_help; /**< @brief set the (new) profile for current operation */
    char ** profile_orig; /* input argv string list*/
    char ** profile_arg; /* value list of char * */
    // Player options:
    int startplayback_given; /* number of times this option was entered */
    const char *startplayback_help; /**< @brief Start playback of audio file */
    char * startplayback_orig; /* input argv string */
    char * startplayback_arg; /* value of type */
    int stopplayback_given; /* number of times this option was entered */
    const char *stopplayback_help; /**< @brief Stop playback if active */
    char * stopplayback_orig; /* input argv string */
    int stopplayback_arg; /* value of type */
    int audiopath_given; /* number of times this option was entered */
    const char *audiopath_help; /**< @brief Path of directory that contains the audio files (optional) */
    char * audiopath_orig; /* input argv string */
    char * audiopath_arg; /* value of type */
    // Generic options:
    int device_given; /* number of times this option was entered */
    const char *device_help; /**< @brief target name for the interface: i2c, serial, socket, i2c dummy, hid, tfausb */
    char * device_orig; /* input argv string */
    char * device_arg; /* value of type */
    int resetmtpex_given; /* number of times this option was entered */
    const char *resetmtpex_help; /**< @brief reset MtpEx register to do re-calibration */
    char * resetmtpex_orig; /* input argv string */
    int resetmtpex_arg; /* value of type */
    int reset_given; /* number of times this option was entered */
    const char *reset_help; /**< @brief initialize I2C registers and set ACS. After the command, the state is same power on reset. */
    char * reset_orig; /* input argv string */
    int reset_arg; /* value of type */
    // Speaker boost options:
    int calibrate_given; /* number of times this option was entered */
    const char *calibrate_help; /**< @brief do calibration with loaded speaker file, --output returns updated speaker file */
    char * calibrate_orig; /* input argv string */
    char * calibrate_arg; /* value of type */
    int calshow_given; /* number of times this option was entered */
    const char *calshow_help; /**< @brief show calibration impedance value */
    char * calshow_orig; /* input argv string */
    int calshow_arg; /* value of type */
    int params_given; /* number of times this option was entered */
    const char *params_help; /**< @brief write the params file directly to the device; depending on header type: patch, speaker, preset, config, drc, eq  */
    char ** params_orig; /* input argv string list*/
    char ** params_arg; /* value list of char * */
    int re0_given; /* number of times this option was entered */
    const char *re0_help; /**< @brief set specified re0 or read the current re0 */
    char * re0_orig; /* input argv string */
    float re0_arg; /* value of type */
    int save_given; /* number of times this option was entered */
    const char *save_help; /**< @brief write settings to binary file without header. The file type extension must be specified as .eq.msg, .drc.msg, .algo.msg, .lsmodel.msg, .speaker etc */
    char * save_orig; /* input argv string */
    char * save_arg; /* value of type */
    // Diagnostics and test options:
    int currentprof_given; /* number of times this option was entered */
    const char *currentprof_help; /**< @brief set the currently (loaded) runing profile to force transition to new profile. This options should be used with profile option */
    char * currentprof_orig; /* input argv string */
    int currentprof_arg; /* value of type */
    int versions_given; /* number of times this option was entered */
    const char *versions_help; /**< @brief print versions and chip rev */
    char * versions_orig; /* input argv string */
    int versions_arg; /* value of type */
    int register_given; /* number of times this option was entered */
    const char *register_help; /**< @brief read tfa register, write if extra arg given */
    char ** register_orig; /* input argv string list*/
    int* register_arg; /* value list of int */
    int regwrite_given; /* number of times this option was entered */
    const char *regwrite_help; /**< @brief write value for register */
    char ** regwrite_orig; /* input argv string list*/
    int* regwrite_arg; /* value list of int */
    int vstepmsg_given; /* number of times this option was entered */
    const char *vstepmsg_help; /**< @brief write value to select specific message inside the volumestep */
    char * vstepmsg_orig; /* input argv string */
    int vstepmsg_arg; /* value of type */
    int dump_given; /* number of times this option was entered */
    const char *dump_help; /**< @brief dump all defined registers or container */
    char * dump_orig; /* input argv string */
    char * dump_arg; /* value of type */
    int pin_given; /* number of times this option was entered */
    const char *pin_help; /**< @brief control devkit signal pin */
    char * pin_orig; /* input argv string */
    char * pin_arg; /* value of type */
    int wait_given; /* number of times this option was entered */
    const char *wait_help; /**< @brief timeout value (msec) for pinevent (0=forever) */
    char * wait_orig; /* input argv string */
    char * wait_arg; /* value of type */
    int diag_given; /* number of times this option was entered */
    const char *diag_help; /**< @brief run all tests, or single if testnr;it can't be used with --slave, use -l instead;optional extra argument: [i2s|dsp|sb|pins] */
    char * diag_orig; /* input argv string */
    int diag_arg; /* value of type */
    int xmem_given; /* number of times this option was entered */
    const char *xmem_help; /**< @brief access (read/write) tfa xmem */
    char ** xmem_orig; /* input argv string list*/
    int* xmem_arg; /* value list of int */
    int ymem_given; /* number of times this option was entered */
    const char *ymem_help; /**< @brief access (read/write) tfa ymem */
    char ** ymem_orig; /* input argv string list*/
    int* ymem_arg; /* value list of int */
    int pmem_given; /* number of times this option was entered */
    const char *pmem_help; /**< @brief access (read/write) tfa pmem */
    char ** pmem_orig; /* input argv string list*/
    int* pmem_arg; /* value list of int */
    int iomem_given; /* number of times this option was entered */
    const char *iomem_help; /**< @brief access (read/write) tfa iomem */
    char ** iomem_orig; /* input argv string list*/
    int* iomem_arg; /* value list of int */
    int speaker_given; /* number of times this option was entered */
    const char *speaker_help; /**< @brief speaker side select: Left, Right, Both or Disable */
    char * speaker_orig; /* input argv string */
    char * speaker_arg; /* value of type */
    // Live data options:
    int dumpmodel_given; /* number of times this option was entered */
    const char *dumpmodel_help; /**< @brief dump current speakermodel impedance=z, excursion=x, excursion_dsp_based=e, MBDrcDynamics=d[hex_filt_select,filt_type_1,ftype_2,_3..] */
    char * dumpmodel_orig; /* input argv string */
    char * dumpmodel_arg; /* value of type */
    int record_given; /* number of times this option was entered */
    const char *record_help; /**< @brief record speaker state info via I2C and display */
    char * record_orig; /* input argv string */
    int record_arg; /* value of type */
    int count_given; /* number of times this option was entered */
    const char *count_help; /**< @brief number of read cycles to execute, 0 means forever */
    char * count_orig; /* input argv string */
    int count_arg; /* value of type */
    int output_given; /* number of times this option was entered */
    const char *output_help; /**< @brief specify the output file for binary speaker state info records, default=stdout */
    char * output_orig; /* input argv string */
    char * output_arg; /* value of type */
    int logger_given; /* number of times this option was entered */
    const char *logger_help; /**< @brief start datalogger, recording <count> state info lines and binary Z/Xmodels */
    char * logger_orig; /* input argv string */
    int logger_arg; /* value of type */
    // Container file handling options:
    int ini2cnt_given; /* number of times this option was entered */
    const char *ini2cnt_help; /**< @brief Generate the container file from an ini file <this>.ini to <this>.cnt */
    char * ini2cnt_orig; /* input argv string */
    char * ini2cnt_arg; /* value of type */
    int cnt2hdr_given; /* number of times this option was entered */
    const char *cnt2hdr_help; /**< @brief Generate a header file from input file(s) & save it into an output file. --cnt2hdr=fileIn1.<type>,fileIn2.<type>,fileIn3.<type> --output=fileOut.h hdrInfo1 hdrInfo2 hdrInfo3 etc */
    char ** cnt2hdr_orig; /* input argv string list*/
    char ** cnt2hdr_arg; /* value list of char * */
    int bin2hdr_given; /* number of times this option was entered */
    const char *bin2hdr_help; /**< @brief Generate a file with header from input binary file.<type> [customer] [application] [type]. Original file is backed up as file.<type>.old file */
    char * bin2hdr_orig; /* input argv string */
    char * bin2hdr_arg; /* value of type */
    int info_given; /* number of times this option was entered */
    const char *info_help; /**< @brief Specify the information to be filled in MSG header while using bin2hdr option. FW_APIVersion = ITF version in a.b.c.d format. SamplingRate = Sampling Rate.Eg:48000           CustID = Customer ID as integer < 0x7FFFFFFF                                                               Eg: --bin2hdr=File1.msg -I 7.42.1.2,48000,2147 */
    char ** info_orig; /* input argv string list*/
    char ** info_arg; /* value list of char * */
    int gethdr_given; /* number of times this option was entered */
    const char *gethdr_help; /**< @brief Read the Header of a given file and print it. If there is a APIV, SmFr, CuID information in header, it will be returned in string format. The strings need to be allocated and passed by application. */
    char * gethdr_orig; /* input argv string */
    char * gethdr_arg; /* value of type */
    int tfa_given; /* number of times this option was entered */
    const char *tfa_help; /**< @brief provide the tfa device type */
    char ** tfa_orig; /* input argv string list*/
    int* tfa_arg; /* value list of int */
    // Generic options:
    int load_given; /* number of times this option was entered */
    const char *load_help; /**< @brief read parameter settings from container file */
    char * load_orig; /* input argv string */
    char * load_arg; /* value of type */
    int splitparms_given; /* number of times this option was entered */
    const char *splitparms_help; /**< @brief save parameters of the loaded container file to separate parameter files */
    char * splitparms_orig; /* input argv string */
    char * splitparms_arg; /* value of type */
    int msgblob_given; /* number of times this option was entered */
    const char *msgblob_help; /**< @brief save all relevant DSP messages from the loaded container file to a single binary */
    char * msgblob_orig; /* input argv string */
    char * msgblob_arg; /* value of type */
    int server_given; /* number of times this option was entered */
    const char *server_help; /**< @brief run as server (for Linux only, default=`9887') */
    char * server_orig; /* input argv string */
    char * server_arg; /* value of type */
    int client_given; /* number of times this option was entered */
    const char *client_help; /**< @brief run as client (for Linux only, default=`9887') */
    char * client_orig; /* input argv string */
    char * client_arg; /* value of type */
    int slave_given; /* number of times this option was entered */
    const char *slave_help; /**< @brief override hardcoded I2C slave address */
    char * slave_orig; /* input argv string */
    int slave_arg; /* value of type */
    int loop_given; /* number of times this option was entered */
    const char *loop_help; /**< @brief loop the operation [0=forever] */
    char * loop_orig; /* input argv string */
    int loop_arg; /* value of type */
    int verbose_given; /* number of times this option was entered */
    const char *verbose_help; /**< @brief Enable verbose (mask=timing|system|protocol|plugins|hal|tfa|service|climax) */
    char * verbose_orig; /* input argv string */
    int verbose_arg; /* value of type */
    int monitor_given; /* number of times this option was entered */
    const char *monitor_help; /**< @brief Show interpreted I2C writes via dummy */
    char * monitor_orig; /* input argv string */
    int monitor_arg; /* value of type */
    int trace_given; /* number of times this option was entered */
    const char *trace_help; /**< @brief Enable I2C transaction tracing to stdout/file */
    char * trace_orig; /* input argv string */
    char * trace_arg; /* value of type */
    int rpc_given; /* number of times this option was entered */
    const char *rpc_help; /**< @brief Enable DSP communication while the audio processing is running */
    char * rpc_orig; /* input argv string */
    int rpc_arg; /* value of type */
    int input_given; /* number of times this option was entered */
    const char *input_help; /**< @brief specify the input file <x|y|io>mem file */
    char * input_orig; /* input argv string */
    char * input_arg; /* value of type */
    int auto_given; /* number of times this option was entered */
    const char *auto_help; /**< @brief Information to auto connect */
    char * auto_orig; /* input argv string */
    int auto_arg; /* value of type */
    int distofilter_given; /* number of times this option was entered */
    const char *distofilter_help; /**< @brief dump magnitude of the frequency responses of the filters in the distortion reduction module of the DSP algorithm. Usage: --distofilter=n where n=length of the frequency response returned. Has to be greater than 0 and shall be power of 2. */
    char * distofilter_orig; /* input argv string */
    int distofilter_arg; /* value of type */
};
void cmdline_parser_print_help(void);

int cmdline_parser(int argc, char *argv[], struct gengetopt_args_info *options);
void cmdline_parser_free(struct gengetopt_args_info *options);

#endif

